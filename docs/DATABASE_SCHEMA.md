# CipherSQLStudio — Database Schema Design

> **Type:** Architectural Reference Only  
> **You must implement the actual Mongoose schemas and SQL DDL yourself.**  
> This document defines field names, types, relationships, and design rationale.

---

## DUAL DATABASE STRATEGY

| Database          | Role           | What It Stores                             |
| ----------------- | -------------- | ------------------------------------------ |
| **MongoDB Atlas** | Persistence DB | Users, Assignments, Submissions, Hints log |
| **PostgreSQL**    | Sandbox DB     | Student-queryable datasets (read-only)     |

These two databases serve **completely different purposes** — do not confuse them.

---

## PART 1 — MONGODB ATLAS (Mongoose)

### Collection 1: `users`

**Purpose:** Authentication and profile data

```
Field              Type        Notes
─────────────────────────────────────────────────────
_id                ObjectId    Auto-generated by MongoDB
email              String      Unique, lowercase, trimmed, indexed
hashedPassword     String      bcrypt output — NEVER plain text
role               String      Enum: ["student", "admin"]
displayName        String      Optional, user-set nickname
createdAt          Date        Auto via timestamps: true
updatedAt          Date        Auto via timestamps: true
lastLoginAt        Date        Update on every successful login
refreshTokenHash   String      Hashed refresh token (one active at a time)
```

**Indexes to create:**

```
email        → unique index (for login lookup speed)
createdAt    → for admin sorting
```

**Design Notes:**

- `password` field must be `select: false` in Mongoose schema so it's never returned by default
- `refreshTokenHash` stores a hashed (not plain) refresh token — hash it with `crypto.createHash('sha256')`
- Never add a plain `password` field — only `hashedPassword`

---

### Collection 2: `assignments`

**Purpose:** The SQL challenge definitions

```
Field              Type          Notes
─────────────────────────────────────────────────────
_id                ObjectId      Auto-generated
title              String        Required, 3–120 chars
description        String        What the student must achieve
difficulty         String        Enum: ["easy", "medium", "hard"]
category           String        Enum: ["SELECT", "JOIN", "GROUP_BY", "SUBQUERY", "AGGREGATE"]
expectedOutput     Object        { columns: [], rows: [[]] } — for validation comparison
schemaDescription  String        Human-readable table structure (for LLM prompt, NOT actual DDL)
postgresSchema     String        The search_path schema name in sandbox DB
solutionExists     Boolean       true if auto-grading is enabled
orderIndex         Number        Display order on dashboard
isPublished        Boolean       Unpublished assignments are admin-only
createdBy          ObjectId      Ref: users._id
createdAt          Date
updatedAt          Date
```

**Indexes to create:**

```
difficulty    → for filtering
isPublished   → for dashboard queries
category      → for filtering
orderIndex    → for ordering
```

**Design Notes:**

- `expectedOutput` is used for automated result comparison, NOT shown to students
- `schemaDescription` is a text summary (e.g. "Table: employees(id, name, dept_id, salary)") — safe to send to LLM
- `postgresSchema` maps to the PostgreSQL schema name (e.g. `"assignment_3_schema"`)
- Never store actual solution SQL in this collection — security risk

---

### Collection 3: `submissions`

**Purpose:** Audit trail of every query a student runs

```
Field              Type          Notes
─────────────────────────────────────────────────────
_id                ObjectId      Auto-generated
userId             ObjectId      Ref: users._id, indexed
assignmentId       ObjectId      Ref: assignments._id, indexed
query              String        The SQL the student submitted (store as-is)
status             String        Enum: ["correct", "incorrect", "error", "blocked"]
errorMessage       String        If status is "error" — sanitized pg error
rowCount           Number        Rows returned (null if error)
executionTime      Number        Milliseconds to execute
isCorrect          Boolean       Result of auto-grade comparison
attemptNumber      Number        Increments per user per assignment
createdAt          Date
```

**Indexes to create:**

```
userId + assignmentId   → compound index (most common query pattern)
userId + createdAt      → for profile history
status                  → for analytics
```

**Design Notes:**

- Store the raw SQL even for blocked queries — useful for detecting abuse patterns
- `attemptNumber` is computed server-side: `previous attempts count + 1`
- Never store query results in this collection — too large, reconstructable

---

### Collection 4: `hintlogs`

**Purpose:** Audit trail of LLM hint requests (academic integrity)

```
Field              Type          Notes
─────────────────────────────────────────────────────
_id                ObjectId      Auto-generated
userId             ObjectId      Ref: users._id, indexed
assignmentId       ObjectId      Ref: assignments._id
userQuery          String        Query student had when requesting hint
errorMessage       String        Error they saw (if any)
hintReceived       String        The hint text returned from LLM
llmModel           String        Which model was used (e.g. "gpt-4o-mini")
requestedAt        Date
```

**Indexes:**

```
userId + assignmentId + requestedAt   → compound for rate limiting queries
```

**Rate Limit Logic (server-side pseudocode):**

```
countRecentHints = hintlogs.countDocuments({
  userId,
  assignmentId,
  requestedAt: { $gte: one_hour_ago }
})

IF countRecentHints >= 5:
  REJECT with 429 { error: "Hint limit reached. Try again in 1 hour." }
```

---

## PART 2 — POSTGRESQL SANDBOX DESIGN

### Core Design Principle

```
The sandbox PostgreSQL database contains:
  - One schema per assignment
  - Read-only data for students to query
  - A read-only PostgreSQL user that can ONLY SELECT

Students do NOT have write access to ANY table in the sandbox.
```

### Schema Isolation Strategy

```sql
-- Pseudocode structure — you write the actual DDL

CREATE SCHEMA assignment_1_schema;   -- "Employees and Departments"
CREATE SCHEMA assignment_2_schema;   -- "Sales Orders"
CREATE SCHEMA assignment_3_schema;   -- "Library System"
-- ...one schema per assignment

-- ALL tables live inside their assignment's schema
-- The sandbox runner sets: SET search_path TO assignment_N_schema
-- Students cannot access other schemas
```

### Example Schema: Assignment 1 — "Employees" (Conceptual)

```
Tables you should create in assignment_1_schema:

  employees
  ─────────────────────────
  employee_id   INT (PK)
  first_name    VARCHAR
  last_name     VARCHAR
  email         VARCHAR
  salary        NUMERIC(10,2)
  hire_date     DATE
  department_id INT (FK → departments)
  manager_id    INT (FK → employees, self-referential)

  departments
  ─────────────────────────
  department_id   INT (PK)
  department_name VARCHAR
  location        VARCHAR
  budget          NUMERIC(12,2)

  projects
  ─────────────────────────
  project_id      INT (PK)
  project_name    VARCHAR
  start_date      DATE
  end_date        DATE
  department_id   INT (FK → departments)

  employee_projects (junction)
  ─────────────────────────
  employee_id     INT (FK)
  project_id      INT (FK)
  role            VARCHAR
  hours_logged    NUMERIC(6,2)
```

**Why this schema is teaching-rich:**

- Supports: SELECT, JOIN (3+ tables), GROUP BY, HAVING, subqueries, aggregate functions, self-joins
- Each assignment's schema complexity should match its difficulty rating

### Read-Only User Setup (Pseudocode — implement in `init.sql`)

```
CREATE ROLE sandbox_reader WITH LOGIN PASSWORD '...from env...';

-- Grant usage on each schema
GRANT USAGE ON SCHEMA assignment_1_schema TO sandbox_reader;
GRANT USAGE ON SCHEMA assignment_2_schema TO sandbox_reader;
-- ...repeat for all schemas

-- Grant SELECT on all current and FUTURE tables in each schema
GRANT SELECT ON ALL TABLES IN SCHEMA assignment_1_schema TO sandbox_reader;
ALTER DEFAULT PRIVILEGES IN SCHEMA assignment_1_schema
  GRANT SELECT ON TABLES TO sandbox_reader;

-- Explicitly deny write operations (redundant but explicit)
-- sandbox_reader has no INSERT, UPDATE, DELETE, DROP by default
-- The GRANT SELECT is the allowlist — everything else is denied
```

### PostgreSQL Connection Pools (Two Separate Pools)

```
pool_admin (backend internals):
  host: POSTGRES_HOST
  user: POSTGRES_ADMIN_USER
  database: POSTGRES_DB
  max: 5

pool_sandbox (student query execution):
  host: POSTGRES_HOST
  user: sandbox_reader        ← read-only user
  database: POSTGRES_DB
  max: 20                     ← higher concurrency for student queries
```

---

## PART 3 — DATA RELATIONSHIPS (Visual)

```
MongoDB Atlas:

  users (1) ─────────────────< submissions (many)
    │                              │
    │                              └── assignmentId → assignments._id
    │
    └───────────────────────< hintlogs (many)
                                   │
                                   └── assignmentId → assignments._id

  assignments (1) ──────────< submissions (many)
  assignments (1) ──────────< hintlogs (many)


PostgreSQL Sandbox:

  assignment_1_schema.employees  ──FK──> assignment_1_schema.departments
  assignment_1_schema.employee_projects ──FK──> employees + projects
  (student-queryable, read-only)
```

---

## PART 4 — WHAT TO IMPLEMENT, IN ORDER

```
Step 1: MongoDB schemas (Mongoose)
  → User.model.js        (with select: false on hashedPassword)
  → Assignment.model.js  (with virtuals for difficulty label)
  → Submission.model.js  (with compound indexes)
  → HintLog.model.js

Step 2: PostgreSQL init.sql
  → Create schemas
  → Create tables with proper FK constraints
  → Create sandbox_reader role
  → Grant SELECT permissions

Step 3: PostgreSQL seed.sql
  → Insert realistic sample data (not lorem ipsum)
  → At least 20 employees, 5 departments, 10 projects
  → Include edge cases: employees with no projects, NULL salaries

Step 4: Connect both DBs in backend/config/
  → db.mongo.js   → mongoose.connect()
  → db.postgres.js → new pg.Pool() for admin + new pg.Pool() for sandbox
```

---

## COMMON SCHEMA MISTAKES TO AVOID

```
✗  Storing plain text passwords in MongoDB
✓  Only hashedPassword — never store plain text after hashing

✗  Using MongoDB for student query execution
✓  PostgreSQL sandbox only for student queries — MongoDB for app data

✗  One PostgreSQL schema for all assignments
✓  Separate schema (search_path) per assignment for isolation

✗  Using the admin PostgreSQL user in sandbox pool
✓  Dedicated sandbox_reader with GRANT SELECT only

✗  Storing LLM responses in the assignment document
✓  Separate hintlogs collection — keeps assignment schema clean

✗  No indexes on submission queries
✓  Compound index on (userId, assignmentId) — most common lookup

✗  Storing full result rows in submissions collection
✓  Only store rowCount and status — results are reconstructable
```
